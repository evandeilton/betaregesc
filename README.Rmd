---
output: github_document
---

<style>body {text-align: justify}</style>

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error=FALSE, warning=FALSE, message=FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# betaroti

<!-- badges: start -->
[![pkgdown](https://github.com/evandeilton/betaroti/actions/workflows/pkgdown.yaml/badge.svg)](https://github.com/evandeilton/betaroti/actions/workflows/pkgdown.yaml)
<!-- badges: end -->

O pacote `betaroti` oferece uma biblioteca de funções em R para ajuste de modelos de regressão beta em dados ordinais transformados intervalares, com dispersão fixa ou variável. Possibilita simulações para avaliação do desempenho dos modelos no processo de estimação. O código-fonte e contribuições podem ser acessados no repositório oficial do GitHub. Informações detalhadas sobre instalação e uso estão disponíveis na documentação do pacote.

O "betaroti" é voltado para modelagem de dados com variável resposta ordinal numérica transformável em intervalo contínuo (e.g., $y = (y_s;y_i)$), abrangendo censura à esquerda, direita ou intervalar. Aplica-se em pesquisas de opinião, avaliações de produtos, escalas de dor, e avaliações de compostos químicos, entre outros. Utilizando a distribuição beta, acomoda características dos dados em estrutura de regressão, associando variáveis explicativas à variável resposta intervalar e permitindo preditores lineares para coeficientes relacionados à média e dispersão, fornecendo estimativas robustas e confiáveis dos parâmetros do modelo.

## Principais funcionalidades

O pacote `betaroti` oferece uma série de funções úteis para lidar com modelos de regressão beta e dados com resposta ordinal transformada intervalar, abrangendo cenários com dispersão fixa e variável. As principais funcionalidades incluem:

+ Ajuste de modelos de regressão beta com dispersão fixa e variável.
+ Funções para simulação de dados, permitindo a avaliação do desempenho dos modelos em diferentes cenários.
+ Estatística de bondade do ajuste como AIC e BIC, por exemplo em `gof()`.
+ Funções genéricas como `coef`, `vcov`, `fitted`, `residuals`, `summary` e `print` foram implementadas para a classe `betaroti` para facilitar o acesso às medidas do ajuste.
+ Funções para ajuste e comparação de modelos com diferentes combinações de variáveis explicativas tanto para $\mu$ como $\phi$.

Acesse a documentação detalhada de cada função e exemplos de uso neste site para obter informações sobre como utilizar o pacote "betaroti" em suas análises.

## Instalação

Você pode instalar o pacote com esse comando abaixo.

```{r, eval=FALSE}
if(!require(betaroti)){
  devtools::install_github("evandeilton/betaroti")  
}
require(betaroti, quietly = TRUE)
```

```{r, eval=TRUE, echo=FALSE}
require(betaroti, quietly = TRUE)
```


## Exemplos

Esses são alguns exemplos de uso das funções do pacote.

### Simula dados do modelo beta ordinal com dispersão fixa

Esta função gera amostras de variável beta ordinal com dispersão fixa usando várias funções de ligação.

No exemplo a seguir em código R, demonstramos como usar a função beta_ordinal_simula_dados para simular dados de variável beta ordinal com dispersão fixa:

+ Criamos um conjunto de dados com 100 observações e duas variáveis explicativas independentes (x1 e x2) a partir de uma distribuição normal.
+ Utilizamos a função beta_ordinal_simula_dados para simular dados com parâmetros personalizados fornecidos.

> OBS.: `type` é o tipo de tratamento do intervalo `m` centraliza `y` ao meio. Ex. Se foi coletado o valor $y = 6$, transforma-se $y_t = 6/10 = 0.6$. Assim, para tratar a incerteza do instrumento, sugere-se que a medida anotada pode estar limitada a  $y_{left} = 5.5$ e $y_{right} = 6.6$.

```{r}
# Criar um conjunto de dados de exemplo
set.seed(42)
dados <- data.frame(x1 = rnorm(100), x2 = rnorm(100))

dados_simulados <- beta_ordinal_simula_dados(
  formula = ~ x1 + x2,
  dados = dados,
  betas = c(1, -0.3, 0.4),
  phi = 30,
  link = "probit",
  ncuts = 100,
  type = "m"
)
dados_simulados %>%
  head() %>%
  knitr::kable(digits = 4, caption = "")
```

### Ajuste de modelos com dispersão fixa

+ Exemplo do ajuste com optim direto para uma lista de links

```{r}
links <- c("logit", "probit", "cloglog")
names(links) <- links

fit_fixo <- purrr::map(links, .f = function(link){
  betaroti(
    formula = ~x1 + x2,
    dados = dados_simulados,
    link = link,
    link_phi = "identity",
    num_hessiana = TRUE)
})
```

+ Resumo das estimativas e bondade

- Estimativas do ajuste e Bondade
```{r, results='asis'}
resumo <- purrr::map(fit_fixo, function(fit){
  summary(fit)
})
```


```{r}
purrr::map_df(resumo, function(res){
  res$est
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")  
```
```{r}
purrr::map_df(resumo, function(res){
  res$gof
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")
```

+ Exemplo do ajuste com `bbmle` direto para uma lista de links

```{r}
require(bbmle, quietly = TRUE)
links <- c("logit", "probit", "cloglog")
names(links) <- links

fit_fixo_bbmle <- purrr::map(links, .f = function(link){
  betaroti_bbmle(
    formula = ~x1 + x2,
    dados = dados_simulados,
    link = link,
    link_phi = "identity",
    num_hessiana = TRUE)
})
```

- Gráficos dos perfis de verossimilhança

```{r, results='asis'}
fit_fixo_profiles <- purrr::map(fit_fixo_bbmle, profile)
purrr::walk(names(fit_fixo_profiles), function(p){
  cat("\n+", p, "\n")
  plot(fit_fixo_profiles[[p]])
})
```


### Simula dados provenientes de um modelo beta ordinal com dispersão variável.

Neste bloco de código R, é criado um conjunto de dados simulados de um modelo beta ordinal com dispersão variável utilizando a função `beta_ordinal_simula_dados_z.` O processo é resumido abaixo:

+ Definir semente e tamanho da amostra, além das fórmulas para as variáveis explicativas x e z.

+ Criar um conjunto de dados de exemplo com 50 observações e quatro variáveis independentes (x1, x2, z1 e z2), geradas a partir de distribuições normal e uniforme.

+ Utilizar a função `beta_ordinal_simula_dados_z` para gerar dados simulados com base nos parâmetros fornecidos, como fórmulas, coeficientes de regressão, funções de ligação e número de pontos de corte.

```{r}
# Criar um conjunto de dados de exemplo
set.seed(2222)
n <- 50
fx <- ~ x1 + x2 + x3
fz <- ~ z1 + z2

dados <- data.frame(
  x1 = rnorm(n),
  x2 = rnorm(n),
  x3 = rbinom(n, size = 1, prob = 1/2),
  z1 = runif(n),
  z2 = runif(n)
)

dados_simulados <- beta_ordinal_simula_dados_z(
  formula_x = fx,
  formula_z = fz,
  dados = dados,
  betas = c(0.2, -0.6, 0.2, 0.2),
  zetas = c(0.5, 1, 2),
  link_x = "logit",
  link_z = "sqrt",
  ncuts = 100,
  type = "m"
)

dados_simulados %>% 
  head() %>%
  knitr::kable(digits = 4, caption = "")
```

### Ajuste de modelos com dispersão variável

+ Exemplo do ajuste com optim direto para uma lista de links

```{r}
links <- c("logit", "probit", "cloglog")
names(links) <- links

fit_variavel <- purrr::map(links, .f = function(link){
  betaroti(
    formula = ~x1 + x2 + x3 | z1 + z2,
    dados = dados_simulados,
    link = link,
    link_phi = "log",
    num_hessiana = TRUE)
})
```

+ Resumo das estimativas e bondade

- Estimativas do ajuste e Bondade
```{r, results='asis'}
resumo <- purrr::map(fit_variavel, function(fit){
  summary(fit)
})
```


```{r}
purrr::map_df(resumo, function(res){
  res$est
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")  
```

```{r}
purrr::map_df(resumo, function(res){
  res$gof
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")
```

+ Exemplo do ajuste com `bbmle` direto para uma lista de links

```{r}
require(bbmle, quietly = TRUE)
links <- c("logit", "probit", "cloglog")
names(links) <- links

fit_variavel_bbmle <- purrr::map(links, .f = function(link){
  betaroti_bbmle(
    formula = ~x1 + x2 + x3 | z1,
    dados = dados_simulados,
    link = link,
    link_phi = "sqrt",
    num_hessiana = TRUE)
})
```

- Gráficos dos perfis de verossimilhança

```{r, results='asis'}
fit_variavel_profiles <- purrr::map(fit_variavel_bbmle, profile)
purrr::walk(names(fit_variavel_profiles), function(p){
  cat("\n+", p, "\n")
  plot(fit_variavel_profiles[[p]])
})
```



### Outras funções genéricas


```{r, eval=FALSE}
## Resumo das estimativas e bondades
summary(fit_fixo$logit)

## Coeficientes do modelo
coef(fit_fixo$logit)

## Matriz de covariâncias
vcov(fit_fixo$logit)

## Resíduo dos valores preditos em relação ao ponto médio do intervalo de y, 
## isto é (left + right) / 2
resid(fit_fixo$logit)

## Valores preditos
fitted(fit_fixo$logit)

## Print do modelo
print(fit_fixo$logit)
```


----

## Work in progress ...

![](https://media4.giphy.com/media/LHZyixOnHwDDy/giphy.gif)




